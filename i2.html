<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mini FBX Viewer — Refactored</title>
    <style>
        /*
            Refactored CSS
            - единообразные отступы (4 пробела)
            - сохранил визуальную структуру оригинала
        */
        :root {
            --bg: #fff;
            --ink: #111;
            --muted: #667;
            --border: #e5e7eb;
            --accent: #0b57d0;
            --appbarH: 48px;
            --sideW: 460px;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font: 14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
            color: var(--ink);
            background: var(--bg);
        }

        .appbar {
            position: fixed;
            inset: 0 0 auto 0; /* верхняя панель */
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            padding: 0 10px;
            background: #fff;
            border-bottom: 1px solid var(--border);
            z-index: 5;
            min-height: 48px;
        }

        .appbar .row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .appbar .row label {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .btn {
            border: 1px solid var(--border);
            background: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        .btn:hover { border-color: #d0d7de; }

        .muted { color: var(--muted); }

        #viewer {
            position: fixed;
            top: var(--appbarH);
            right: var(--sideW);
            bottom: 0;
            left: 0;
            background: #fafafa;
        }

        .side {
            position: fixed;
            top: var(--appbarH);
            right: 0;
            bottom: 0;
            width: var(--sideW);
            border-left: 1px solid var(--border);
            background: #fff;
            display: flex;
            flex-direction: column;
        }

        .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .list { padding: 8px; overflow: auto; flex: 1; }

        details { border: 1px solid var(--border); border-radius: 10px; padding: 8px; margin: 8px 0; background: #fff; }
        summary { cursor: pointer; font-weight: 600; }

        table { width: 100%; border-collapse: collapse; margin-top: 6px; font-size: 13px; }
        td { padding: 4px 6px; border-top: 1px dashed var(--border); vertical-align: top; }
        td.k { width: 140px; color: #334; }

        .chip { display: inline-block; border: 1px solid var(--border); border-radius: 6px; padding: 0 6px; font-size: 11px; }
        .tag  { display: inline-block; padding: 2px 6px; border: 1px solid var(--border); border-radius: 999px; margin: 2px 4px 0 0; font-size: 12px; }

        select { padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; }
        input[type="range"] { width: 120px; }

        #gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(96px, 1fr)); gap: 8px; padding: 8px; }
        .thumb { border: 1px solid var(--border); border-radius: 10px; padding: 6px; background: #fff; display:flex; flex-direction:column; gap:4px; cursor:pointer; overflow:hidden; }
        .thumb img, .thumb .ph { width:100%; aspect-ratio:1/1; object-fit:cover; border-radius:6px; display:block }
        .thumb .ph { display:grid; place-items:center; font-size:11px; color:#666; background:#f4f4f5 }
        .thumb.broken { border-color:#f5c2c7; background:#fff5f6 }
        .thumb .nm { display:block; max-width:100%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
        .pill { align-self:flex-start; font-size:10px; padding:1px 6px; border:1px solid var(--border); border-radius:999px }

        .gallery-spacer { grid-column: 1 / -1; height: 1px; }

        .drop { position: fixed; inset: var(--appbarH) 0 0 0; display:none; place-items:center; background:rgba(0,0,0,.04); border:3px dashed rgba(0,0,0,.2); font-size:18px; z-index:4 }
        .drop.show { display: grid; }

        .modal { position: fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.45); z-index:50 }
        .modal.show { display:grid }
        .sheet { background:#fff; width:min(900px, calc(100vw - 40px)); border-radius:12px; border:1px solid var(--border); overflow:hidden; box-shadow:0 30px 100px rgba(0,0,0,.25) }
        .sheet .head { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--border) }
        .sheet .body { display:grid; grid-template-columns: 1fr 320px; gap:0 }
        .sheet .imgwrap { background:#111; display:grid; place-items:center; min-height:320px }
        .sheet .imgwrap img { max-width:100%; max-height:70vh }
        .sheet .side { padding:10px; display:flex; flex-direction:column; gap:8px }
        .sheet .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap }
        .sheet .btn.primary { background: var(--accent); color:#fff; border-color:var(--accent) }
        .eye {
            font-size: 14px;
            margin-left: 6px;
            user-select: none;
        }

        body.side-hidden { --sideW: 0px; }
    </style>
</head>
<body>

    <!--
        Refactored single-file viewer.
        - Весь JS разделён на блоки и подробно прокомментирован.
        - Отступы — 4 пробела.
        - Функционал сохранён.
    -->

    <div class="appbar">
        <button id="toggleSideBtn" class="btn" title="Показать/скрыть боковую панель">☰</button>

        <!-- Files -->
        <button id="openBtn" class="btn">Открыть FBX</button>
        <input id="fileInput" type="file" accept=".fbx" multiple hidden />

        <label>point size
            <input type="range" id="pointSize" min="1" max="10" step="1" value="3" />
        </label>

        <!-- IBL / controls -->
        <div class="row">
            <label><input type="checkbox" id="hdriChk" checked /></label>
            <label>HDRI
                <select id="hdriPreset">
                    <option value="">— выберите —</option>
                </select>
            </label>
            <label>bg&nbsp;α <input id="bgAlpha" type="range" min="0" max="1" step="0.01" value="0.00" /></label>
            <label>intensity <input id="iblInt" type="range" min="0" max="3" step="0.05" value="1.5" /></label>
            <label>rot&nbsp;<input id="iblRot" type="range" min="0" max="360" step="1" value="0" /></label>
            
            

            <label>shading
                <select id="shadingMode" title="Режим шейдинга">
                    <option value="pbr" selected>PBR</option>
                    <option value="lambert">Lambert</option>
                    <option value="phong">Phong</option>
                    <option value="toon">Toon</option>
                    <option value="normal">Normal</option>
                    <option value="basic">Unlit</option>
                    <option value="wire">Wireframe</option>
                    <option value="matcap">Matcap</option>
                    <option value="xray">X-Ray</option>
                    <option value="uv">UV Checker</option>
                    <option value="depth">Depth</option>
                    <option value="vcol">Vertex Color</option>
                    <option value="roughOnly">Roughness Only</option>
                    <option value="metalOnly">Metalness Only</option>
                    <option value="points">Points (Vertices)</option>
                </select>
            </label>

            <label>
                <select id="axisSelect" title="Ось вверх">
                    <option value="Y" selected>Y ↑</option>
                    <option value="Z">Z ↑</option>
                </select>
            </label>
        </div>

        <!-- Glass controls -->
        <div class="row" id="glassTopControls">
            <label title="Прозрачность стекла (opacity)">Glass&nbsp;α
                <input id="glassOpacity" type="range" min="0" max="1" step="0.01" value="0.20" />
            </label>
            <label title="Интенсивность отражений у стекла (envMapIntensity)">Reflect
                <input id="glassReflect" type="range" min="0" max="3" step="0.05" value="3.00" />
            </label>
            <label title="Metalness для стекла (если нет карты)">Metal
                <input id="glassMetal" type="range" min="0" max="1" step="0.01" value="1.0" />
            </label>
        </div>

        <div class="spacer"></div>
        <span id="appbarStatus" class="muted"></span>
    </div>

    <div id="viewer"></div>

    <div class="side">
        <div class="row" style="padding:10px; border-bottom:1px solid var(--border)">
            <span id="status" class="muted">—</span>
        </div>

        <div class="list" id="out"><div class="muted">Нет модели. Загрузите .fbx</div></div>

        <details open style="margin:8px">
            <summary>Встроенные картинки · <span id="texCount" class="chip">0</span></summary>
            <div class="row" style="margin:6px 0">
                <select id="matSelect" title="Материал для привязки">
                    <option value="">— выберите материал —</option>
                </select>
                <span class="muted" style="font-size:12px">Выберите материал, затем щёлкните на миниатюре → Привязать…</span>
            </div>
            <div id="gallery"></div>
        </details>

        <details open style="margin:8px">
            <summary>Лог автопривязки</summary>
            <div id="bindLog" style="font-size:13px; line-height:1.4; padding:6px; max-height:220px; overflow:auto; white-space:pre-wrap; background:#fafafa; border:1px solid var(--border); border-radius:6px;">— пока пусто —</div>
        </details>
    </div>

    <div id="drop" class="drop">Бросайте сюда один или несколько .fbx</div>

    <div id="texModal" class="modal">
        <div class="sheet">
            <div class="head">
                <div id="mTitle" class="muted">Карта</div>
                <button id="mClose" class="btn">Закрыть</button>
            </div>
            <div class="body">
                <div class="imgwrap"><img id="mImg" alt=""></div>
                <div class="side">
                    <div><b>Файл:</b> <span id="mFile"></span></div>
                    <div class="row"><span class="pill" id="mKind">other</span> <span class="muted" id="mMime"></span></div>
                    <hr style="border:none; border-top:1px dashed var(--border)">
                    <div class="row">
                        <select id="slotSelect" title="Слот">
                            <option value="map">map (diffuse/base)</option>
                            <option value="alphaMap">alphaMap</option>
                            <option value="normalMap">normalMap</option>
                            <option value="aoMap">aoMap</option>
                            <option value="roughnessMap">roughnessMap</option>
                            <option value="metalnessMap">metalnessMap</option>
                        </select>
                        <button id="bindBtn" class="btn primary">Привязать к материалу</button>
                    </div>
                    <div class="muted" style="font-size:12px">Подсказка: для roughness/metalness — линейный профиль, для map — sRGB.</div>
                    <div style="margin-top:8px">
                        <a id="dlLink" class="btn" download>Скачать картинку</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.179.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.179.1/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script type="module">
        /*
            Полный рефакторинг JS:
            - структурирован по разделам
            - все функции и переменные явно именованы
            - подробные комментарии на русском
            - аккуратные 4-пробельные отступы
        */

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        

        // =====================
        // DOM references
        // =====================
        const rootEl          = document.getElementById('viewer');
        const dropEl          = document.getElementById('drop');
        const statusEl        = document.getElementById('status');
        const appbarStatusEl  = document.getElementById('appbarStatus');
        const shadingSel      = document.getElementById('shadingMode');

        const iblChk          = document.getElementById('hdriChk');
        const hdriPresetSel   = document.getElementById('hdriPreset');
        const iblIntEl        = document.getElementById('iblInt');
        const iblRotEl        = document.getElementById('iblRot');
        const axisSel         = document.getElementById('axisSelect');
        const toggleSideBtn   = document.getElementById('toggleSideBtn');

        const glassOpacityEl  = document.getElementById('glassOpacity');
        const glassReflectEl  = document.getElementById('glassReflect');
        const glassMetalEl    = document.getElementById('glassMetal');

        const outEl           = document.getElementById('out');
        const galleryEl       = document.getElementById('gallery');
        const texCountEl      = document.getElementById('texCount');
        const matSelect       = document.getElementById('matSelect');
        const bindLogEl       = document.getElementById('bindLog');

        const bgAlphaEl       = document.getElementById('bgAlpha');
        bgAlphaEl.addEventListener('input', updateBgVisibility);

        // =====================
        // THREE.js scene init
        // =====================
        const scene    = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f7);

        const world    = new THREE.Group();
        scene.add(world);

        const camera   = new THREE.PerspectiveCamera(60, 1, 0.01, 5000);
        camera.position.set(2.5, 1.5, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        rootEl.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Простое освещение и сетка
        scene.add(new THREE.HemisphereLight(0xffffff, 0xcfd8dc, 1));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(3, 5, 4);
        scene.add(dirLight);

        const grid = new THREE.GridHelper(100, 100, 0xdddddd, 0xeeeeee);
        grid.material.transparent = true;
        grid.material.opacity = 0.5;
        world.add(grid);

        // =====================
        // Loaders & caches
        // =====================
        const fbxLoader      = new FBXLoader();
        const textureLoader  = new THREE.TextureLoader();
        const texLd          = new THREE.TextureLoader(); // for small helper textures

        let pmremGen     = null;      // PMREM generator (lazy)
        let hdrBaseTex   = null;      // original equirect HDR (DataTexture)
        const HDRI_LIBRARY = [
            { name: "Royal Esplanade", url: "https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr" },
            { name: "Venice Sunset",   url: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/venice_sunset_1k.hdr" },
            { name: "Studio Small",    url: "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr" }
        ];
        let currentEnv   = null;      // pmrem result (for scene.environment)
        let currentBg    = null;      // shifted equirect (for background sphere)
        let currentRotDeg = 0;        // rotation slider value

        // =====================
        // State
        // =====================
        const loadedModels = []; // { obj, name }
        const allEmbedded  = []; // embedded images across all models
        const undoStack    = [];

        let bgMesh = null; // background sphere used to show HDRI

        // =====================
        // Layout helper
        // =====================
        function getCssNumber(varName) {
            const v = getComputedStyle(document.body).getPropertyValue(varName).trim();
            const n = parseFloat(v || '0');
            return Number.isFinite(n) ? n : 0;
        }
        // =====================
        // HDRI texture flip Y
        // =====================
        function flipHDRTextureVertically(srcTex) {
            const { data, width, height } = srcTex.image;
            const channels = 4; // RGBA/RGBE
            const flipped = new (data.constructor)(data.length);

            for (let y = 0; y < height; y++) {
                const srcRow = y * width * channels;
                const dstRow = (height - 1 - y) * width * channels;
                flipped.set(data.subarray(srcRow, srcRow + width * channels), dstRow);
            }

            const tex = new THREE.DataTexture(flipped, width, height, srcTex.format, srcTex.type);
            tex.encoding = srcTex.encoding;
            tex.mapping = THREE.EquirectangularReflectionMapping;
            tex.needsUpdate = true;

            return tex;
        }

        function layout() {
            // 1) measure header height and set CSS var
            const appbar = document.querySelector('.appbar');
            const appH = Math.ceil(appbar?.getBoundingClientRect().height || 48);
            document.body.style.setProperty('--appbarH', appH + 'px');

            // 2) compute canvas size (account for side panel)
            const sideW = getCssNumber('--sideW');
            const w = Math.max(1, window.innerWidth - sideW);
            const h = Math.max(1, window.innerHeight - appH);
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }

        window.addEventListener('resize', layout);
        toggleSideBtn.addEventListener('click', () => { document.body.classList.toggle('side-hidden'); layout(); });

        // =====================
        // Camera framing helpers
        // =====================
        function focusOn(targets, pad = 1.4) {
            // targets may be an object or array of objects
            const box = new THREE.Box3();
            const add = (obj) => obj && box.expandByObject(obj);

            if (Array.isArray(targets)) {
                let any = false;
                targets.forEach(o => { if (o) { add(o); any = true; } });
                if (!any) return;
            } else if (targets) {
                add(targets);
            } else return;

            if (box.isEmpty()) return;

            const size = new THREE.Vector3();
            const center = new THREE.Vector3();
            box.getSize(size);
            box.getCenter(center);
            controls.target.copy(center);

            const fov = THREE.MathUtils.degToRad(camera.fov);
            const canvas = renderer.domElement;
            const aspect = canvas.clientWidth / Math.max(canvas.clientHeight, 1);
            const maxDim = Math.max(size.x, size.y, size.z);

            const distForH = (maxDim / (2 * Math.tan(fov / 2)));
            const distForW = (maxDim * aspect / (2 * Math.tan(fov / 2)));
            const dist = Math.max(distForH, distForW) * pad;

            const dirv = new THREE.Vector3(1, 0.6, 1).normalize();
            camera.position.copy(center.clone().add(dirv.multiplyScalar(dist)));
            camera.near = Math.max(dist / 1000, 0.01);
            camera.far = dist * 1000;
            camera.updateProjectionMatrix();
            controls.update();
        }

        function fitAll() {
            const box = new THREE.Box3();
            let any = false;
            world.children.forEach(ch => { box.expandByObject(ch); any = true; });
            if (!any || box.isEmpty()) return;

            const size = new THREE.Vector3();
            const center = new THREE.Vector3();
            box.getSize(size);
            box.getCenter(center);
            controls.target.copy(center);

            const canvas = renderer.domElement;
            const fov = THREE.MathUtils.degToRad(camera.fov);
            const aspect = canvas.clientWidth / Math.max(canvas.clientHeight, 1);
            const max = Math.max(size.x, size.y, size.z);
            const dist = Math.max(max / (2 * Math.tan(fov / 2)), (max * aspect) / (2 * Math.tan(fov / 2))) * 1.5;

            camera.position.copy(center.clone().add(new THREE.Vector3(1, 0.6, 1).normalize().multiplyScalar(dist)));
            camera.near = Math.max(dist / 1000, 0.01);
            camera.far = dist * 1000;
            camera.updateProjectionMatrix();
        }

        function computeWorldCenter() {
            const box = new THREE.Box3();
            let any = false;
            world.children.forEach(ch => { box.expandByObject(ch); any = true; });
            if (!any || box.isEmpty()) return new THREE.Vector3(0, 0, 0);
            const center = new THREE.Vector3();
            box.getCenter(center);
            return center;
        }

        // =====================
        // HDR / IBL handling
        // =====================
        async function loadHDRBase() {
            if (hdrBaseTex) return hdrBaseTex;
            const base = 'https://threejs.org/examples/textures/equirectangular/';
            const file = 'royal_esplanade_1k.hdr';
            hdrBaseTex = await new RGBELoader().setPath(base).loadAsync(file);
            hdrBaseTex.mapping = THREE.EquirectangularReflectionMapping;
            hdrBaseTex.wrapS = THREE.RepeatWrapping;
            hdrBaseTex.wrapT = THREE.ClampToEdgeWrapping;
            hdrBaseTex.flipY = false;
            hdrBaseTex.flipX = false;
            hdrBaseTex.flipZ = false;
            hdrBaseTex.needsUpdate = true;
            return hdrBaseTex;
        }

        // shift equirectangular map in U direction by a fraction [0..1)
        function shiftEquirectColumns(srcTex, fracU) {
            const img = srcTex.image;
            const w = img.width, h = img.height;
            const ch = 4; // RGBA / RGBE
            const data = img.data;
            const out = new (data.constructor)(data.length);

            const shift = Math.round(((fracU % 1 + 1) % 1) * w);
            for (let y = 0; y < h; y++) {
                const rowOff = y * w * ch;
                for (let x = 0; x < w; x++) {
                    const sx = (x - shift + w) % w;
                    const si = rowOff + sx * ch;
                    const di = rowOff + x * ch;
                    out[di] = data[si];
                    out[di + 1] = data[si + 1];
                    out[di + 2] = data[si + 2];
                    out[di + 3] = data[si + 3];
                }
            }

            const tex = new THREE.DataTexture(out, w, h, srcTex.format, srcTex.type);
            tex.encoding = srcTex.encoding;
            tex.mapping = THREE.EquirectangularReflectionMapping;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.ClampToEdgeWrapping;
            tex.needsUpdate = true;
            return tex;
        }

        // build PMREM from rotated HDR and apply to scene.environment
        function buildAndApplyEnvFromRotation(deg) {
            currentRotDeg = deg;
            if (!pmremGen) pmremGen = new THREE.PMREMGenerator(renderer);

            const frac = ((deg % 360) + 360) % 360 / 360;
            if (bgMesh) {
                bgMesh.rotation.y = THREE.MathUtils.degToRad(deg);
            }
            // dispose previous
            if (currentEnv) { currentEnv.dispose?.(); currentEnv = null; }
            if (currentBg) { currentBg.dispose?.(); currentBg = null; }

            // shift source HDR and generate PMREM
            const shifted = shiftEquirectColumns(hdrBaseTex, frac);
            currentBg = shifted;
            const rt = pmremGen.fromEquirectangular(shifted);
            currentEnv = rt.texture;

            scene.environment = iblChk.checked ? currentEnv : null;
            applyEnvToMaterials(scene.environment, parseFloat(iblIntEl.value));
        }

        async function setEnvironmentEnabled(on) {
            await loadHDRBase();
            if (on) {
                buildAndApplyEnvFromRotation(currentRotDeg || 0);
            } else {
                scene.environment = null;
                applyEnvToMaterials(null, 1.0);
                if (bgMesh) bgMesh.visible = false;
            }
            updateBgVisibility();
            applyGlassControlsToScene();
        }

        function applyEnvToMaterials(env, intensity) {
            world.traverse(o => {
                if (!o.isMesh || !o.material) return;
                const mats = Array.isArray(o.material) ? o.material : [o.material];
                mats.forEach(m => {
                    if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) {
                        m.envMap = env;
                        m.envMapIntensity = intensity;
                        m.needsUpdate = true;
                    }
                });
            });
        }

        // helper textures
        let _matcapTex = null;
        let _checkerTex = null;

        function getMatcap() {
            if (_matcapTex) return _matcapTex;
            _matcapTex = texLd.load('https://threejs.org/examples/textures/matcaps/matcap-porcelain-white.jpg');
            return _matcapTex;
        }

        function getChecker() {
            if (_checkerTex) return _checkerTex;
            const S = 256, N = 8;
            const c = document.createElement('canvas'); c.width = c.height = S;
            const g = c.getContext('2d');
            for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
                g.fillStyle = ((x + y) & 1) ? '#bbbbbb' : '#222222';
                g.fillRect(x * S / N, y * S / N, S / N, S / N);
            }
            _checkerTex = new THREE.CanvasTexture(c);
            _checkerTex.wrapS = _checkerTex.wrapT = THREE.RepeatWrapping;
            _checkerTex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
            return _checkerTex;
        }

        // =====================
        // Points mode (vertices visualization)
        // =====================
        function createPointsForMesh(mesh) {
            // create Points object that shares mesh.geometry but has its own material
            const pm = new THREE.PointsMaterial({
                size: 3.0,
                sizeAttenuation: false,
                color: 0x111111,
                vertexColors: !!mesh.geometry.getAttribute('color'),
                transparent: true,
                opacity: 0.95
            });

            const points = new THREE.Points(mesh.geometry, pm);
            points.name = mesh.name ? `${mesh.name}_points` : 'points';

            const parent = mesh.parent || world;
            parent.add(points);

            points.position.copy(mesh.position);
            points.quaternion.copy(mesh.quaternion);
            points.scale.copy(mesh.scale);

            mesh.userData._points = points;
            return points;
        }

        function destroyPointsForMesh(mesh) {
            const p = mesh.userData._points;
            if (p && p.parent) {
                p.parent.remove(p);
                p.geometry = null; // do not dispose shared geometry
                p.material.dispose?.();
            }
            delete mesh.userData._points;
        }

        function ensurePointsForMesh(mesh, size = 3, color = 0x00aaff) {
            if (!mesh.isMesh || !mesh.geometry || !mesh.parent) return null;

            if (!mesh.userData._pointsObj) {
                const pm = new THREE.PointsMaterial({ size, sizeAttenuation: false, color, depthTest: true, depthWrite: false });
                const pts = new THREE.Points(mesh.geometry, pm);
                pts.name = (mesh.name || mesh.type) + ' (points)';
                pts.renderOrder = (mesh.renderOrder || 0) + 1;
                pts.visible = false;

                mesh.parent.add(pts);
                pts.position.copy(mesh.position);
                pts.quaternion.copy(mesh.quaternion);
                pts.scale.copy(mesh.scale);

                mesh.userData._pointsObj = pts;
                mesh.userData._pointsMat = pm;
            } else {
                const pm = mesh.userData._pointsMat;
                if (pm) { pm.size = size; pm.color = new THREE.Color(color); pm.needsUpdate = true; }
            }
            return mesh.userData._pointsObj;
        }

        function setPointsMode(enabled, { size = 0.5, color = 0x666666 } = {}) {
            world.traverse(o => {
                if (!o.isMesh) return;
                const pts = ensurePointsForMesh(o, size, color);
                if (!pts) return;
                o.visible = !enabled;
                pts.visible = enabled;
            });
        }

        function updatePointSize(newSize) {
            world.traverse(o => {
                if (o.userData?._pointsMat?.isPointsMaterial) {
                    o.userData._pointsMat.size = newSize;
                    o.userData._pointsMat.needsUpdate = true;
                }
            });
        }

        document.getElementById('pointSize').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            world.traverse(o => {
                if (o.isPoints && o.material?.isPointsMaterial) {
                    o.material.size = val;
                    o.material.needsUpdate = true;
                }
            });
        });

        // =====================
        // Shading modes
        // =====================
        function makeVariantFrom(orig, mode) {
            const common = { side: THREE.FrontSide, transparent: !!orig.transparent, opacity: orig.opacity ?? 1 };
            const color = (orig.color && orig.color.isColor) ? orig.color.clone() : new THREE.Color(0xffffff);
            const map = orig.map || null;

            switch (mode) {
                case 'lambert':
                    return new THREE.MeshLambertMaterial({ ...common, color, map });
                case 'phong':
                    return new THREE.MeshPhongMaterial({ ...common, color, map, shininess: 50, specular: new THREE.Color(0x111111) });
                case 'toon':
                    return new THREE.MeshToonMaterial({ ...common, color, map });
                case 'normal':
                    return new THREE.MeshNormalMaterial({ ...common, flatShading: false });
                case 'basic':
                    return new THREE.MeshBasicMaterial({ ...common, color: map ? 0xffffff : color, map });
                case 'wire':
                    return new THREE.MeshBasicMaterial({ ...common, color: 0x000000, wireframe: true, opacity: 0.25 });
                case 'matcap':
                    return new THREE.MeshMatcapMaterial({ ...common, color: 0xffffff, matcap: getMatcap() });
                case 'xray':
                    return new THREE.MeshBasicMaterial({ ...common, color: 0xaaaaaa, transparent: true, opacity: 0.25, depthWrite: false });
                case 'uv':
                    return new THREE.MeshBasicMaterial({ ...common, color: 0xffffff, map: getChecker() });
                case 'depth':
                    return new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking });
                case 'vcol':
                    return new THREE.MeshBasicMaterial({ ...common, vertexColors: true });
                case 'roughOnly': {
                    const tex = orig.roughnessMap || null;
                    if (tex) return new THREE.MeshBasicMaterial({ ...common, color: 0xffffff, map: tex });
                    const v = Math.max(0, Math.min(1, Number(orig.roughness ?? 0.5)));
                    const c = new THREE.Color().setScalar(v);
                    return new THREE.MeshBasicMaterial({ ...common, color: c });
                }
                case 'metalOnly': {
                    const tex = orig.metalnessMap || null;
                    if (tex) return new THREE.MeshBasicMaterial({ ...common, color: 0xffffff, map: tex });
                    const v = Math.max(0, Math.min(1, Number(orig.metalness ?? 0.0)));
                    const c = new THREE.Color().setScalar(v);
                    return new THREE.MeshBasicMaterial({ ...common, color: c });
                }
                default:
                    return orig; // pbr
            }
        }

        function applyShading(mode) {
            if (mode === 'points') {
                setPointsMode(true, { size: 3, color: 0x00aaff });
                return;
            } else {
                setPointsMode(false);
            }

            world.traverse(obj => {
                if (!obj.isMesh || !obj.material) return;
                if (!obj.userData._origMaterial) obj.userData._origMaterial = obj.material;
                const origArray = Array.isArray(obj.userData._origMaterial) ? obj.userData._origMaterial : [obj.userData._origMaterial];
                if (mode === 'pbr') {
                    obj.material = obj.userData._origMaterial;
                } else {
                    const variants = origArray.map(m => makeVariantFrom(m, mode));
                    obj.material = variants.length === 1 ? variants[0] : variants;
                }
            });

            if (mode === 'pbr') {
                applyEnvToMaterials(scene.environment, parseFloat(iblIntEl.value));
                applyGlassControlsToScene();
            }
            renderMaterialsPanel();
        }

        shadingSel.addEventListener('change', () => applyShading(shadingSel.value));

        // =====================
        // Objects visibility
        // =====================


        function toggleVisibilityById(id, el) {
            let target = null;

            // ищем объект в world по userData._panelId
            world.traverse(o => {
                if ((o.userData?._panelId) === id) target = o;
            });

            if (!target) return;

            target.visible = !target.visible;
            el.textContent = target.visible ? '👁' : '🚫';
        }


        // =====================
        // Background sphere helpers
        // =====================
        function ensureBgMesh() {
            if (bgMesh) return bgMesh;
            const geo = new THREE.SphereGeometry(100000, 64, 32);
            const mat = new THREE.MeshBasicMaterial({ map: null, side: THREE.BackSide, depthWrite: false, toneMapped: false, transparent: true, opacity: parseFloat(bgAlphaEl.value || '1') });
            bgMesh = new THREE.Mesh(geo, mat);
            scene.add(bgMesh);
            return bgMesh;
        }

        function updateBgVisibility() {
            if (!bgMesh) return;
            bgMesh.visible = !!iblChk.checked;
            bgMesh.material.opacity = parseFloat(bgAlphaEl.value || '1');
            bgMesh.material.transparent = bgMesh.material.opacity < 0.999;
            bgMesh.material.needsUpdate = true;
        }

        iblChk.addEventListener('change', () => setEnvironmentEnabled(iblChk.checked));
        iblIntEl.addEventListener('input', () => { if (iblChk.checked) applyEnvToMaterials(scene.environment, parseFloat(iblIntEl.value)); });
        iblRotEl.addEventListener('input', async () => { if (!iblChk.checked) return; await loadHDRBase(); buildAndApplyEnvFromRotation(parseFloat(iblRotEl.value) || 0); });
        hdriPresetSel.addEventListener('change', async (e) => {
            const idx = parseInt(e.target.value, 10);
            if (isNaN(idx)) return;
            const entry = HDRI_LIBRARY[idx];
            if (!entry) return;

            hdrBaseTex = await new RGBELoader().loadAsync(entry.url);
            hdrBaseTex = flipHDRTextureVertically(hdrBaseTex);
            hdrBaseTex.mapping = THREE.EquirectangularReflectionMapping;
            hdrBaseTex.wrapS = THREE.RepeatWrapping;
            hdrBaseTex.wrapT = THREE.ClampToEdgeWrapping;
            
            hdrBaseTex.needsUpdate = true;

            buildAndApplyEnvFromRotation(parseFloat(iblRotEl.value) || 0);
            ensureBgMesh();
            bgMesh.material.map = currentBg;
            bgMesh.material.needsUpdate = true;
        });
        // =====================
        // Axis toggle
        // =====================
        function setAxisUp(up = 'Y') {
            if (up === 'Z') {
                camera.up.set(0, 0, 1);
                world.rotation.set(Math.PI / 2, 0, 0);
            } else {
                camera.up.set(0, 1, 0);
                world.rotation.set(0, 0, 0);
            }
            controls.update();
            fitAll();
        }

        axisSel.addEventListener('change', () => setAxisUp(axisSel.value));
        setAxisUp('Y');

        // =====================
        // Utilities
        // =====================
        function basename(p) { return (p || '').split(/[\\\/]/).pop(); }

        function guessKindFromName(name) {
            const n = (name || '').toLowerCase();
            if (/(rough|rgh|_rough|\br_)/.test(n)) return 'roughness';
            if (/gloss/.test(n)) return 'gloss';
            if (/(metal|mtl|\b_m\b)/.test(n)) return 'metalness';
            if (/(normal|_nrm|_nor)\b/.test(n)) return 'normal';
            if (/ao|ambient[_-]?occ/i.test(n)) return 'ao';
            if (/opacity|alpha|transp/i.test(n)) return 'alpha';
            if (/basecolor|albedo|diff(use)?/i.test(n)) return 'base';
            if (/spec(ular)?/i.test(n)) return 'spec';
            return 'other';
        }

        function texInfo(tex) {
            if (!tex) return '<span class="muted">—</span>';
            const human = tex.name || tex.userData?.origName || null;
            let rawSrc = '';
            const img = tex.image;
            if (img) rawSrc = img.currentSrc || img.src || img.url || '';
            const fallback = basename(decodeURIComponent(String(rawSrc || '')).split('?')[0] || '');
            const pretty = human || fallback || '(texture)';
            const cs = tex?.colorSpace === THREE.SRGBColorSpace ? 'srgb' : tex?.colorSpace === THREE.LinearSRGBColorSpace ? 'srgb-linear' : (tex?.colorSpace ?? '—');
            return `${pretty}  ·  ${cs}`;
        }

        function logBind(message, level = 'info') {
            if (!bindLogEl) return;
            const prefix = level === 'warn' ? '⚠️ ' : level === 'ok' ? '✅ ' : '';
            if (bindLogEl.textContent.trim() === '— пока пусто —') { bindLogEl.textContent = ''; }
            bindLogEl.textContent += prefix + message + '\n';
        }

        function logSessionHeader(title) {
            if (!bindLogEl) return;
            const ts = new Date().toLocaleTimeString();
            if (bindLogEl.textContent.trim() !== '— пока пусто —') { bindLogEl.textContent += '\n'; }
            bindLogEl.textContent += `——— ${title} @ ${ts} ———\n`;
        }

        // =====================
        // FBX embedded images extraction
        // =====================
        function isBinaryFBX(arrayBuffer) {
            const sig = new Uint8Array(arrayBuffer, 0, 23);
            const magic = 'Kaydara FBX Binary  \0';
            for (let i = 0; i < magic.length; i++) { if (sig[i] !== magic.charCodeAt(i)) return false; }
            return true;
        }

        function sniffImage(u8) {
            let mime = 'application/octet-stream';
            if (u8[0] === 0x89 && u8[1] === 0x50 && u8[2] === 0x4E && u8[3] === 0x47) mime = 'image/png';
            else if (u8[0] === 0xFF && u8[1] === 0xD8) mime = 'image/jpeg';
            else if (u8[0] === 0x47 && u8[1] === 0x49 && u8[2] === 0x46) mime = 'image/gif';
            else if (u8[0] === 0x52 && u8[1] === 0x49 && u8[2] === 0x46 && u8[8] === 0x57 && u8[9] === 0x45) mime = 'image/webp';
            return { mime };
        }

        async function extractImagesFromFBX(arrayBuffer) {
            return isBinaryFBX(arrayBuffer) ? extractEmbeddedImagesFromFBX_binary(arrayBuffer) : extractEmbeddedImagesFromFBX_ascii(arrayBuffer);
        }

        async function extractEmbeddedImagesFromFBX_ascii(arrayBuffer) {
            const text = new TextDecoder('latin1').decode(new Uint8Array(arrayBuffer));
            const videos = [];
            const rxVideo = /Video::([^,\"\s]+)[^{]*?(?:FileName|RelativeFilename)\s*:\s*\"([^\"]+)\"/gi;
            let mv;
            while ((mv = rxVideo.exec(text))) videos.push({ nameInFbx: mv[1], filePath: mv[2] });

            const out = [];
            const rxContent = /Content\s*:\s*,/g;
            let mc, idx = 0;
            while ((mc = rxContent.exec(text))) {
                const start = mc.index + mc[0].length;
                const chunk = text.slice(start, start + 8_000_000);
                const b64m = chunk.match(/([A-Za-z0-9+\/=\r\n]{800,})/);
                if (!b64m) continue;
                const b64 = b64m[1].replace(/\s+/g, '');
                try {
                    const bin = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
                    const { mime } = sniffImage(bin);
                    const url = URL.createObjectURL(new Blob([bin], { type: mime }));
                    const vid = videos[idx++] || {};
                    const filePath = vid.filePath || `embedded_${out.length}.${(mime.split('/')[1] || 'img')}`;
                    const short = basename(filePath).toLowerCase();
                    out.push({ short, url, full: filePath, mime, source: 'embedded' });
                } catch (__) { /* ignore decode errors */ }
            }
            return out;
        }

        function extractEmbeddedImagesFromFBX_binary(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const version = view.getUint32(23, true);
            const is64 = version >= 7500;
            const u8 = new Uint8Array(arrayBuffer);
            const td = new TextDecoder('utf-8');

            const u32 = (o) => view.getUint32(o, true);
            const u64 = (o) => { const low = view.getUint32(o, true), high = view.getUint32(o + 4, true); return high * 0x100000000 + low; };
            const readLen = (o) => is64 ? u64(o) : u32(o);

            function readNode(offset) {
                const endOffset = readLen(offset); offset += is64 ? 8 : 4;
                const numProps = readLen(offset); offset += is64 ? 8 : 4;
                const propsLen = readLen(offset); offset += is64 ? 8 : 4;
                const nameLen = view.getUint8(offset); offset += 1;
                if (endOffset === 0) return { nextOffset: endOffset, nullRecord: true };

                const name = td.decode(u8.subarray(offset, offset + nameLen)); offset += nameLen;
                const props = [];

                for (let i = 0; i < numProps; i++) {
                    const t = String.fromCharCode(view.getUint8(offset)); offset += 1;
                    if (t === 'S' || t === 'R') {
                        const len = u32(offset); offset += 4;
                        const data = u8.subarray(offset, offset + len); offset += len;
                        props.push({ type: t, data });
                    } else if (t === 'Y') { offset += 2; props.push({ type: t }); }
                    else if (t === 'C') { offset += 1; props.push({ type: t }); }
                    else if (t === 'I') { offset += 4; props.push({ type: t }); }
                    else if (t === 'F') { offset += 4; props.push({ type: t }); }
                    else if (t === 'D') { offset += 8; props.push({ type: t }); }
                    else if (t === 'L') { offset += 8; props.push({ type: t }); }
                    else if ('bcdfil'.includes(t)) {
                        const arrayLen = u32(offset); offset += 4;
                        const encoding = u32(offset); offset += 4;
                        const compLen = u32(offset); offset += 4;
                        if (encoding === 0) {
                            const elemSize = (t === 'd' || t === 'D') ? 8 : (t === 'l' || t === 'L' || t === 'i' || t === 'I') ? 4 : (t === 'f' || t === 'F') ? 4 : 1;
                            offset += arrayLen * elemSize;
                        } else {
                            offset += compLen;
                        }
                        props.push({ type: t, array: true });
                    } else {
                        return { name, props, children: [], nextOffset: endOffset };
                    }
                }

                const children = [];
                while (offset < endOffset) {
                    const child = readNode(offset);
                    if (child.nullRecord) { offset = is64 ? offset + 25 : offset + 13; break; }
                    children.push(child);
                    offset = child.nextOffset;
                }
                return { name, props, children, nextOffset: endOffset };
            }

            let offset = 27;
            const top = [];
            while (offset < arrayBuffer.byteLength) {
                const node = readNode(offset);
                if (!node || node.nullRecord) break;
                top.push(node);
                offset = node.nextOffset || (offset + 1);
            }

            const videos = [];
            (function visit(n) { if (!n) return; if (Array.isArray(n)) return n.forEach(visit); if (n.name === 'Video') videos.push(n); if (n.children) n.children.forEach(visit); })(top);

            const out = [];
            for (const vid of videos) {
                let filePath = null, content = null;
                const stack = [...(vid.children || [])];
                while (stack.length) {
                    const c = stack.shift();
                    if (!c) continue;
                    if (c.name === 'FileName' || c.name === 'RelativeFilename') {
                        const p = c.props?.[0];
                        if (p && p.type === 'S') filePath = new TextDecoder('utf-8').decode(p.data).replace(/\0/g, '');
                    }
                    if (c.name === 'Content') {
                        const p = c.props?.[0];
                        if (p && p.type === 'R') content = p.data;
                    }
                    if (c.children) stack.push(...c.children);
                }
                if (content) {
                    const { mime } = sniffImage(content);
                    const url = URL.createObjectURL(new Blob([content], { type: mime }));
                    const short = basename(filePath || `embedded_${out.length}.${(mime.split('/')[1] || 'img')}`).toLowerCase();
                    out.push({ short, url, full: filePath || short, mime, source: 'embedded' });
                }
            }
            return out;
        }

        // =====================
        // Material helpers
        // =====================
        function toStandard(m) {
            if (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial) return m;
            const std = new THREE.MeshStandardMaterial({
                side: THREE.FrontSide,
                color: m.color?.clone?.() ?? new THREE.Color(0xffffff),
                map: m.map ?? null,
                normalMap: m.normalMap ?? null,
                aoMap: m.aoMap ?? null,
                emissive: m.emissive?.clone?.() ?? new THREE.Color(0x000000),
                emissiveMap: m.emissiveMap ?? null,
                emissiveIntensity: m.emissiveIntensity ?? 1.0,
                transparent: !!m.transparent,
                opacity: m.opacity ?? 1.0,
                metalness: 0.0,
                roughness: Math.max(0.04, 1 - (m.shininess ?? 30) / 100)
            });

            if (std.map) std.map.colorSpace = THREE.SRGBColorSpace;
            if (std.emissiveMap) std.emissiveMap.colorSpace = THREE.SRGBColorSpace;
            if (std.normalMap) std.normalMap.colorSpace = THREE.LinearSRGBColorSpace;
            if (std.aoMap) std.aoMap.colorSpace = THREE.LinearSRGBColorSpace;
            if (m.alphaMap) { std.alphaMap = m.alphaMap; std.alphaMap.colorSpace = THREE.LinearSRGBColorSpace; std.alphaTest = 0.5; std.transparent = false; std.depthWrite = true; }
            if (scene.environment) { std.envMap = scene.environment; std.envMapIntensity = parseFloat(iblIntEl.value); }
            return std;
        }

        const GEOM_SUFFIXES = ['mainglass', 'main', 'groundglass', 'groundelglass', 'groundel', 'ground', 'flora'];

        function findGeomSuffix(label) {
            const s = (label || '').toLowerCase();
            for (const g of GEOM_SUFFIXES) {
                const re = new RegExp(`(?:^|[^a-z0-9])${g}(?:[^a-z0-9]|$)`, 'i');
                if (re.test(s)) return g;
            }
            return null;
        }

        function isGlassGeomSuffix(geomSuffix) { return /^(mainglass|groundglass|groundelglass)$/.test((geomSuffix || '').toLowerCase()); }
        function isGlassByName(name) { return /\b(mainglass|groundglass|groundelglass)\b/.test((name || '').toLowerCase()); }

        // =====================
        // Materials panel
        // =====================
        
        function renderMaterialsPanel() {
            const chunks = [];
            chunks.push('<details open><summary>Объекты</summary>');

            loadedModels.forEach((model, modelIdx) => {
                const modelId = `model-${modelIdx}`;
                const eyeId = `eye-${modelId}`;

                // FBX файл
                chunks.push(`
                    <details open>
                        <summary>
                            <span>${model.name}</span>
                            <span class="eye" data-target="${modelId}" title="Показать/скрыть">👁</span>
                        </summary>
                `);

                model.obj.traverse((obj, objIdx) => {
                    if (!obj.isMesh || !obj.material) return;
                    const mats = Array.isArray(obj.material) ? obj.material : [obj.material];

                    mats.forEach((m, idx) => {
                        const humanIdx = idx + 1;
                        const matName = m.name || obj.name || `${m.type}`;
                        const title = `${matName}${mats.length > 1 ? ` [${humanIdx}]` : ''}`;

                        const present = [];
                        ['map', 'alphaMap', 'normalMap', 'bumpMap', 'aoMap', 'emissiveMap',
                        'specularMap', 'roughnessMap', 'metalnessMap']
                        .forEach(k => { if (m[k]) present.push(`<span class="tag">${k}</span>`); });

                        const objId = `${modelId}-mesh-${obj.uuid}-${idx}`;

                        chunks.push(`
                            <details>
                                <summary>
                                    <span>${title}</span>
                                    <span class="eye" data-target="${objId}" title="Показать/скрыть">👁</span>
                                </summary>
                                <table>
                                    <tr><td class="k">Карты</td><td>${present.length ? present.join(' ') : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">Diffuse</td><td>${m.map ? texInfo(m.map) : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">Alpha</td><td>${m.alphaMap ? texInfo(m.alphaMap) : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">Normal</td><td>${m.normalMap ? texInfo(m.normalMap) : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">AO</td><td>${m.aoMap ? texInfo(m.aoMap) : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">Roughness</td><td>${m.roughnessMap ? texInfo(m.roughnessMap) : '<span class="muted">—</span>'}</td></tr>
                                    <tr><td class="k">Metalness</td><td>${m.metalnessMap ? texInfo(m.metalnessMap) : '<span class="muted">—</span>'}</td></tr>
                                </table>
                            </details>
                        `);

                        // сохраняем ссылку на объект, чтобы потом находить по клику
                        obj.userData._panelId = objId;
                    });
                });

                model.obj.userData._panelId = modelId;

                chunks.push('</details>'); // close file
            });

            chunks.push('</details>'); // close "Объекты"
            outEl.innerHTML = chunks.join('\n');
            rebuildMaterialsDropdown();

            // обработчики глазиков
            outEl.querySelectorAll('.eye').forEach(el => {
                el.style.cursor = 'pointer';
                el.addEventListener('click', () => {
                    const id = el.dataset.target;
                    toggleVisibilityById(id, el);
                });
            });
        }

        // =====================
        // Gallery / modal
        // =====================
        function renderGallery(listAll) {
            galleryEl.innerHTML = '';
            const total = Array.isArray(listAll) ? listAll.length : 0;

            (listAll || []).forEach((e, i) => {
                const div = document.createElement('div'); div.className = 'thumb';
                const nm = document.createElement('div'); nm.className = 'nm';
                nm.title = (e.full || e.short || '') + (e.fileName ? ` — ${e.fileName}` : '');
                nm.textContent = (e.short || `(entry ${i})`);
                const pill = document.createElement('span'); pill.className = 'pill';
                pill.textContent = guessKindFromName(e.short) + (e.fileName ? ` · ${basename(e.fileName)}` : '');

                const imgWrap = document.createElement('div');
                if (e && e.url) {
                    const img = document.createElement('img'); img.loading = 'lazy'; img.decoding = 'async'; img.alt = e.short || ''; img.src = e.url;
                    img.onerror = () => { div.classList.add('broken'); img.replaceWith(makePlaceholder(e)); };
                    imgWrap.appendChild(img);
                } else { div.classList.add('broken'); imgWrap.appendChild(makePlaceholder(e)); }

                div.appendChild(imgWrap); div.appendChild(nm); div.appendChild(pill);
                div.addEventListener('click', () => openTexModal(e));
                galleryEl.appendChild(div);

                function makePlaceholder(entry) { const ph = document.createElement('div'); ph.className = 'ph'; ph.textContent = entry?.mime ? entry.mime : 'preview error'; return ph; }
            });

            const spacer = document.createElement('div'); spacer.className = 'gallery-spacer'; galleryEl.appendChild(spacer);
            texCountEl.textContent = String(total);
        }

        const texModal = document.getElementById('texModal');
        const mClose = document.getElementById('mClose');
        const mImg = document.getElementById('mImg');
        const mTitle = document.getElementById('mTitle');
        const mFile = document.getElementById('mFile');
        const mKind = document.getElementById('mKind');
        const mMime = document.getElementById('mMime');
        const dlLink = document.getElementById('dlLink');
        const bindBtn = document.getElementById('bindBtn');
        const slotSelect = document.getElementById('slotSelect');

        let modalTex = null;
        function openTexModal(entry) {
            modalTex = entry;
            mImg.src = entry.url;
            mTitle.textContent = (entry.full || entry.short) + (entry.fileName ? ` — ${entry.fileName}` : '');
            mFile.textContent = entry.short;
            mKind.textContent = guessKindFromName(entry.short);
            mMime.textContent = entry.mime || '';
            dlLink.href = entry.url; dlLink.download = basename(entry.short);
            texModal.classList.add('show');

            if (matSelect && (matSelect.value === '' || matSelect.selectedIndex <= 0) && matSelect.options.length > 1) { matSelect.selectedIndex = 1; }

            const k = guessKindFromName(entry.short);
            slotSelect.value = k === 'base' ? 'map' : k === 'alpha' ? 'alphaMap' : k === 'normal' ? 'normalMap' : k === 'ao' ? 'aoMap' : (k === 'roughness' || k === 'gloss') ? 'roughnessMap' : k === 'metalness' ? 'metalnessMap' : 'map';
        }

        mClose.addEventListener('click', () => texModal.classList.remove('show'));
        texModal.addEventListener('click', (e) => { if (e.target === texModal) texModal.classList.remove('show'); });

        bindBtn.addEventListener('click', () => {
            if (!modalTex) return;
            const mat = getSelectedMaterial();
            if (!mat) { alert('Выберите материал в выпадающем списке'); return; }
            const slot = slotSelect.value;
            const linear = !(slot === 'map' || slot === 'emissiveMap');
            const t = textureLoader.load(modalTex.url);
            const humanName = basename(modalTex.full || modalTex.short);
            t.name = humanName; (t.userData ||= {}).origName = humanName;
            t.colorSpace = linear ? THREE.LinearSRGBColorSpace : THREE.SRGBColorSpace;
            if (slot === 'roughnessMap') { mat.roughnessMap = t; mat.roughness = 0.6; }
            else if (slot === 'metalnessMap') { mat.metalnessMap = t; mat.metalness = 1.0; }
            else if (slot === 'alphaMap') { mat.alphaMap = t; mat.alphaTest = 0.5; mat.transparent = false; mat.depthWrite = true; }
            else { mat[slot] = t; }
            const std = toStandard(mat);
            if (scene.environment) { std.envMap = scene.environment; std.envMapIntensity = parseFloat(iblIntEl.value); }
            std.needsUpdate = true;
            renderMaterialsPanel();
            logBind(`${modalTex.short} → ${mat.name || 'материал'}.${slot}`, 'ok');
        });

        // =====================
        // Glass controls
        // =====================
        function applyGlassControlsToScene() {
            const op = parseFloat(glassOpacityEl?.value ?? 0.2);
            const refl = parseFloat(glassReflectEl?.value ?? 1.0);
            const metal = parseFloat(glassMetalEl?.value ?? 1.0);

            world.traverse(o => {
                if (!o.isMesh || !o.material) return;
                const mats = Array.isArray(o.material) ? o.material : [o.material];
                mats.forEach((m, i) => {
                    const nameStr = `${m.name || ''} ${o.name || ''}`;
                    const geomSuffix = findGeomSuffix(nameStr);
                    const glass = isGlassByName(nameStr) || isGlassGeomSuffix(geomSuffix);
                    if (!glass) return;

                    const std = toStandard(m);
                    std.transparent = true;
                    std.opacity = op;
                    std.envMap = scene.environment || std.envMap;
                    std.envMapIntensity = refl;
                    if (!std.metalnessMap) std.metalness = metal;
                    if (!std.roughnessMap) std.roughness = Math.min(std.roughness ?? 0.12, 0.05);
                    std.needsUpdate = true;

                    if (Array.isArray(o.material)) { o.material[i] = std; } else { o.material = std; }
                });
            });
        }

        [glassOpacityEl, glassReflectEl, glassMetalEl].forEach(el => {
            el?.addEventListener('input', () => { applyGlassControlsToScene(); renderer.render(scene, camera); });
        });

        // =====================
        // Auto-bind based on filenames
        // =====================
        function parseTexName(filename) {
            const base = basename(filename).toLowerCase().replace(/\.[a-z0-9]+$/i, '');
            const parts = base.split('_');
            if (parts.length < 3) return null;
            const last = parts.pop();
            const map = parts.pop();
            const geom = parts.pop();
            const code3 = parts.length ? parts[parts.length - 1] : null;
            const id = parseInt(last, 10);
            if (!Number.isFinite(id)) return null;
            const geomOk = GEOM_SUFFIXES.includes(geom) ? geom : null; if (!geomOk) return null;
            const kindMap = { d: 'base', n: 'normal', o: 'alpha', m: 'metalness', r: 'roughness' };
            return { id, mapSuffix: map, geomSuffix: geomOk, code3: /^\d{3}$/.test(code3 || '') ? code3 : null, kind: kindMap[map] || guessKindFromName(filename) };
        }

        function kindToSlot(kind) {
            switch (kind) {
                case 'base': return 'map';
                case 'normal': return 'normalMap';
                case 'alpha': return 'alphaMap';
                case 'metalness': return 'metalnessMap';
                case 'roughness': return 'roughnessMap';
                case 'ao': return 'aoMap';
                default: return null;
            }
        }

        function indexModelMaterials(root) {
            const idx = new Map();
            root.traverse(o => {
                if (!o.isMesh || !o.material) return;
                const mats = Array.isArray(o.material) ? o.material : [o.material];
                mats.forEach((m, i) => {
                    const materialId = i + 1;
                    const label = `${m.name || ''} ${o.name || ''}`.toLowerCase();
                    const code3Match = label.match(/(^|[_\W])(\d{3})([_\W]|$)/);
                    const code3 = code3Match ? code3Match[2] : null;
                    const geom = findGeomSuffix(label);
                    const keys = [];
                    if (geom) { keys.push(`${code3 || '—'}|${geom}|${materialId}`); keys.push(`—|${geom}|${materialId}`); }
                    keys.push(`${code3 || '—'}|—|${materialId}`); keys.push(`—|—|${materialId}`);
                    keys.forEach(k => { if (!idx.has(k)) idx.set(k, { obj: o, material: m, slotIndex: i, materialId, geom, code3 }); });
                });
            });
            return idx;
        }

        function autoBindByNamesForModel(root, fileName, embeddedList) {
            const history = [];
            const matIndex = indexModelMaterials(root);
            embeddedList.forEach(tex => {
                const p = parseTexName(tex.short);
                if (!p) { logBind(`⚠️ ${tex.short} — не распознан шаблон имени`, 'warn'); return; }
                const { id, geomSuffix, code3, kind } = p;
                const slot = kindToSlot(kind);
                if (!slot) { logBind(`⚠️ ${tex.short} — нераспознан тип карты`, 'warn'); return; }
                const keyWith = `${code3 || '—'}|${geomSuffix}|${id}`;
                const keyNoC3 = `—|${geomSuffix}|${id}`;
                let target = matIndex.get(keyWith) || matIndex.get(keyNoC3);
                if (!target) { logBind(`⚠️ ${tex.short} — нет материала по «${code3 || '—'} / ${geomSuffix} / id:${id}»`, 'warn'); return; }

                const mats = Array.isArray(target.obj.material) ? target.obj.material : [target.obj.material];
                let m = mats[target.slotIndex];
                m = toStandard(m);
                mats[target.slotIndex] = m; target.obj.material = Array.isArray(target.obj.material) ? mats : m;

                const t = textureLoader.load(tex.url);
                const humanName = basename(tex.full || tex.short);
                t.name = humanName; (t.userData ||= {}).origName = humanName;
                t.colorSpace = (slot === 'map' || slot === 'emissiveMap') ? THREE.SRGBColorSpace : THREE.LinearSRGBColorSpace;

                if (m[slot]) { logBind(`⚠️ ${tex.short} — слот ${slot} уже занят`, 'warn'); return; }

                if (slot === 'roughnessMap') { m.roughnessMap = t; m.roughness = 0.6; }
                else if (slot === 'metalnessMap') { m.metalnessMap = t; m.metalness = 1.0; }
                else if (slot === 'alphaMap') { m.alphaMap = t; m.alphaTest = 0.5; m.transparent = false; m.depthWrite = true; }
                else { m[slot] = t; }

                if (scene.environment) { m.envMap = scene.environment; m.envMapIntensity = parseFloat(iblIntEl.value); }
                m.needsUpdate = true;
                history.push({ obj: target.obj, matIndex: target.slotIndex, slot, prev: null, url: tex.url, tex });
                logBind(`✅ ${tex.short} → ${m.name || 'материал'}.${slot}`, 'ok');
            });
            if (history.length) undoStack.push({ fileName, bindings: history });
        }

        // =====================
        // Dropdown & material collection
        // =====================
        function rebuildMaterialsDropdown() {
            const items = collectMaterialsFromWorld();
            matSelect.innerHTML = '<option value="">— выберите материал —</option>';
            items.forEach((it, i) => {
                const opt = document.createElement('option'); opt.value = String(i); opt.textContent = it.label; matSelect.appendChild(opt);
            });
            matSelect.dataset._map = JSON.stringify(items.map((x, idx) => ({ idx, path: x.path })));
        }

        function collectMaterialsFromWorld() {
            const out = [];
            world.traverse(o => {
                if (!o.isMesh || !o.material) return;
                const mats = Array.isArray(o.material) ? o.material : [o.material];
                mats.forEach((m, i) => {
                    const humanIdx = i + 1;
                    const label = `${o.name || o.type} · ${m.type}${m.name ? ` (${m.name})` : ''}${mats.length > 1 ? ` [${humanIdx}]` : ''}`;
                    out.push({ obj: o, index: i, label, path: `${o.uuid}:${i}` });
                });
            });
            return out;
        }

        function getSelectedMaterial() {
            if (matSelect && (matSelect.value === '' || matSelect.selectedIndex <= 0) && matSelect.options.length > 1) { matSelect.selectedIndex = 1; }
            const val = matSelect?.value; if (val === '' || val == null) return null;
            let map = [];
            try { map = JSON.parse(matSelect.dataset._map || '[]'); } catch { map = []; }
            const entry = map.find(e => String(e.idx) === String(val)); if (!entry || !entry.path) return null;
            const [uuid, idxStr] = String(entry.path).split(':'); const targetIndex = parseInt(idxStr, 10) || 0;
            let found = null;
            world.traverse(o => { if (found || !o.isMesh) return; if (o.uuid !== uuid) return; const mats = Array.isArray(o.material) ? o.material : [o.material]; found = mats[targetIndex] || null; });
            return found;
        }

        // =====================
        // File flow
        // =====================
        const fileInput = document.getElementById('fileInput');
        const openBtn = document.getElementById('openBtn');

        openBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', async (e) => {
            const files = [...(e.target.files || [])];
            for (const f of files) {
                if (/\.fbx$/i.test(f.name)) {
                    await handleFBXFile(f);
                } else if (/\.zip$/i.test(f.name)) {
                    await handleZIPFile(f);
                }
            }
            await finalizeBatchAfterAllFiles();
        });

        ['dragenter','dragover'].forEach(ev => window.addEventListener(ev, e => { e.preventDefault(); dropEl.classList.add('show'); }));
        ['dragleave','drop'].forEach(ev => window.addEventListener(ev, e => { e.preventDefault(); if (ev === 'drop') return; dropEl.classList.remove('show'); }));

        window.addEventListener('drop', async e => {
            e.preventDefault(); dropEl.classList.remove('show');
            const files = [...(e.dataTransfer?.files || [])];
            for (const f of files) {
                if (/\.fbx$/i.test(f.name)) {
                    await handleFBXFile(f);
                } else if (/\.zip$/i.test(f.name)) {
                    await handleZIPFile(f);
                }
            }
            await finalizeBatchAfterAllFiles();
        });

        async function handleFBXFile(file) {
            logSessionHeader(`FBX: ${file.name}`);
            // statusEl.textContent = `Чтение FBX: ${file.name}…`;
            // appbarStatusEl.textContent = statusEl.textContent;

            const ab = await file.arrayBuffer();

            // statusEl.textContent = `Извлекаю встроенные карты: ${file.name}…`;
            // appbarStatusEl.textContent = statusEl.textContent;
            const embedded = await extractImagesFromFBX(ab);
            embedded.forEach(e => e.fileName = file.name);
            allEmbedded.push(...embedded);
            renderGallery(allEmbedded);

            // statusEl.textContent = `Загружаю модель: ${file.name}…`;
            // appbarStatusEl.textContent = statusEl.textContent;
            const url = URL.createObjectURL(new Blob([ab], { type: 'model/fbx' }));

            await new Promise((resolve, reject) => {
                fbxLoader.load(url, async obj => {
                    URL.revokeObjectURL(url);
                    obj.rotation.x = -Math.PI / 2; // Z-up -> Y-up correction
                    world.add(obj);
                    loadedModels.push({ obj, name: file.name });

                    autoBindByNamesForModel(obj, file.name, embedded);
                    applyGlassControlsToScene();

                    renderMaterialsPanel();
                    applyShading(shadingSel.value);
                    fitAll();
                    focusOn(loadedModels.map(m => m.obj));

                    // statusEl.textContent = `Готово: ${file.name} · карт: ${embedded.length}`;
                    // appbarStatusEl.textContent = statusEl.textContent;
                    resolve();
                }, undefined, err => {
                    URL.revokeObjectURL(url);
                    statusEl.textContent = `Ошибка загрузки: ${file.name}`;
                    appbarStatusEl.textContent = statusEl.textContent;
                    logBind(`⚠️ Ошибка загрузки ${file.name}: ${err?.message || String(err)}`, 'warn');
                    reject(err);
                });
            });
        }

        async function handleZIPFile(file) {
            logSessionHeader(`ZIP: ${file.name}`);
            statusEl.textContent = `Чтение ZIP: ${file.name}…`;
            appbarStatusEl.textContent = statusEl.textContent;

            const zip = await JSZip.loadAsync(file);
            const entries = Object.values(zip.files);

            // сначала FBX
            for (const entry of entries) {
                if (entry.dir) continue;
                if (/\.fbx$/i.test(entry.name)) {
                    const ab = await entry.async("arraybuffer");
                    const fbxFile = new File([ab], basename(entry.name), { type: "model/fbx" });
                    await handleFBXFile(fbxFile);
                }
            }

            // потом картинки
            for (const entry of entries) {
                if (entry.dir) continue;
                if (/\.(png|jpe?g|webp)$/i.test(entry.name)) {
                    const blob = await entry.async("blob");
                    const url = URL.createObjectURL(blob);
                    const short = basename(entry.name).toLowerCase();
                    allEmbedded.push({ short, url, full: entry.name, mime: blob.type || "image/png", source: "zip" });
                }
            }

            renderGallery(allEmbedded);

            // statusEl.textContent = `Готово: ${file.name} · моделей и текстур добавлено`;
            // appbarStatusEl.textContent = statusEl.textContent;
        }

        async function finalizeBatchAfterAllFiles() {
            if (!loadedModels.length) return;

            const center = computeWorldCenter();

            if (iblChk.checked) {
                await loadHDRBase();
                buildAndApplyEnvFromRotation(parseFloat(iblRotEl.value) || 0);
            }

            ensureBgMesh();
            bgMesh.position.copy(center);
            bgMesh.material.map = currentBg || null;
            bgMesh.material.needsUpdate = true;
            updateBgVisibility();

            applyGlassControlsToScene();
        }

        // =====================
        // Animation loop & init
        // =====================
        (function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();
        layout();
        HDRI_LIBRARY.forEach((h, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = h.name;
            hdriPresetSel.appendChild(opt);
        });
        // IBL не запускаем автоматически — управляется чекбоксом
    </script>
</body>
</html>